<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head>
  <link rel="stylesheet" type="text/css" href="../josiahMinimal.css" media="screen" />
  <link rel="stylesheet" type="text/css" href="../Fonts/stylesheet.css" media="screen" />

  <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300,700,800' rel='stylesheet' type='text/css'>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.14 (458244)"/><meta name="altitude" content="256.6947631835938"/><meta name="author" content="josiah@josiahbruner.com"/><meta name="created" content="2019-12-05 00:55:29 +0000"/><meta name="latitude" content="42.29091152261812"/><meta name="longitude" content="-83.71574666829547"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2020-01-31 01:05:18 +0000"/><title>Josiah's Secure Computing Systems Notes</title></head>

<body>
  <div id="mainheader">
      <a href="../index.html">
        <div id="topbox"> J </div>
      </a>
      <div id="otherbox"> Josiah Bruner. </div>
  </div>
  <div><span style="font-size: 18px;">OS Security</span></div><ul><li><div>Usually refer to the “keeper of the keys” as the “Trusted Computing Base"</div></li><ul><li><div>Usually the OS (or Hypervisor)</div></li></ul><li><div>TCB must be tamper proof, un-bypassable, and vulnerability free (partially unrealistic)</div></li><li><div>TCB response for: Authentication, Authorization, and Auditing</div></li><li><div>TCSEC defined a set of criteria (followed by Common criteria) which defined a set of expectations.</div></li><li><div>Trusted Policy Module (TPM) is a HW-based root of trust that does platform measurement, attestation, etc.</div></li><ul><li><div>Standard owned by TCG</div></li></ul><li><div>Principles of systems security</div></li><ul><li><div>Security cost must be appropriate with threat level and asset level (defender vs. attacker cost curves)</div></li><li><div>Should be easy enough to use</div></li><li><div>System should be as simple as possible (economy of mechanism)</div></li><ul><li><div>Corollary: Don’t rely on obscurity</div></li><li><div>e.g. TCB —&gt; Hypervisor</div></li></ul><li><div>Least privilege and separation of privilege</div></li><li><div>Defense in depth</div></li></ul></ul><div><br/></div><div><span style="font-size: 18px;">Requirements of HW</span></div><ul><li><div>HW necessary component of separation (TCB). We have to trust it (simplification)</div></li><li><div>Unit of protection: Address space + Privileged instructions</div></li><li><div>x86 Example</div></li><ul><li><div>Modes: Real, Protected, Long/Flat</div><div/></li><li><div>Logical Address Space per Process —&gt; Physical Address map required</div></li><li><div>Address space divided into logical units (segments). e.g. code, data, stack, etc.</div></li><li><div>Segment further divided (pages). Pages are fixed size (e.g. 4KB in 32bit x86)</div></li><li><div>Logical Address: (Segment number, page number, page offset)</div></li><ul><li><div>Global and local segment descriptor tables (GDT, LDT) store segment mappings</div></li><li><div>Page table for pages, etc.</div></li></ul><li><div>Address Translation:</div><div/></li><ul><li><div>Logical Address = (segment number, displacement)</div></li><li><div>Physical = *(SGTBR + STE * STE Size) + displacement</div></li><ul><li><div>SGTBR = Segment Base Register</div></li><li><div>STE = Segment Table Entry # (segment number)</div></li></ul><li><div>Complicated by segment selectors and paging</div></li></ul><li><div>Each segment gets protection bits (representing protection level or DPL). 0 - 3 (0 most privileged)</div><div/></li><ul><li><div>DPL: Descriptor protection level</div></li></ul><li><div>Current Protection Level (CPL)</div></li><ul><li><div>DPL of the code segment being executed</div></li></ul><li><div>Requestor Privilege Level (RPL)</div></li><ul><li><div>Specified in segment selector</div></li><li><div>Check: Max (CPL, RPL) &lt;= DPL of target</div></li><li><div>Why RPL? To avoid privilege execution (kernel executing code on behalf of an application)</div></li></ul><li><div>Page level Protection</div><div/></li><ul><li><div>PPL (page protection level) of 0 (privileged) and 1 (non-priv)</div></li><li><div>CPL with 3 can only access PPL 1</div></li><li><div>Read-write protection</div></li><li><div>Execute disable protection</div></li><li><div>Can combine segment and page protections</div></li></ul><li><div>Changing Privilege Level</div></li><ul><li><div>Call Gates</div></li><ul><li><div>Specify code segment to access</div></li><li><div>Specify privilege level required for *caller*</div></li><li><div>Entry point for procure in called code segment</div></li><li><div>Number and size of parameters when stacks are to be switched</div></li><li><div>Privilege Check</div></li></ul><li><div>Intel now has SYSENTER &amp; SYSEXIT (SYSCALL &amp; SYSRET)</div></li><ul><li><div>Previously used interrupts</div></li></ul></ul><li><div>Privileged Instructions</div></li><ul><li><div>Can only be executed at CPL 0</div></li><li><div>e.g. LGDT, LLDT, MOV (control registers), HLT, etc.</div></li></ul></ul><li><div>Attack examples including row hammer, kernel rootkits, etc.</div></li></ul><div><span style="font-size: 18px;"><br/></span></div><div><span style="font-size: 18px;">Virtualization &amp; Security</span></div><ul><li><div>Simplifies the TCB</div></li><li><div>Assumes IO instructions are privileged (this wasn’t always true)</div></li><li><div>VMM Types: Type 1 (Hostless) Type 2 (Hosted)</div><div/></li><ul><li><div>Simplicity argument probably only applies to type 1</div></li></ul><li><div>Green &amp; Red Virtual Machines</div><div/></li><ul><li><div>Green VM: Machine with “good” apps. Red VM: Machine with malicious apps.</div></li><li><div>VMM provides isolation between apps / operating systems.</div></li></ul><li><div>VMM Requirements</div></li><ul><li><div>Transparency: VMM must provide execution environment which is identical to underlying physical machine (ignoring some performance degradation)</div></li><li><div>Complete Mediation: No way to bypass VMMs control on physical resources</div></li><li><div>Efficiency: Most VM instructions should execute natively</div></li><li><div>Requirements for Type 1 VMM</div></li><ul><li><div>Non-privileged instructions should be executed natively (in the same way).</div></li><li><div>Privileged instructions must be trapped and mediated</div></li><ul><li><div>Instructions that reference mode of VM and state of physical machine</div></li><li><div>Instructions that read/write sensitive registers or memory</div></li><li><div>Instructions that impact memory protection system and address translation</div></li></ul></ul><li><div>OS Aware it is not ring 0: Para-virtualization. Requires changes to OS</div></li></ul><li><div>Ring concept: VMM (Ring -1) —&gt; Ring 0 (“root”) —&gt; Ring 3 ("App Space")</div></li><li><div>Intel SGX: HW-protected enclave that protects data in an address space that can’t be accessed including the hypervisor</div></li></ul><div><br/></div><div><span style="font-size: 18px;">Authentication</span></div><ul><li><div>Login flow: Make claim, provide evidence, verify via system, give process a UID</div></li><li><div>Auth methods:</div></li><ul><li><div>Goal: Easy for correct user and hard for attacker</div><div/></li><li><div>User Friendly: High True Positives. Low False Negatives.</div></li><li><div>Strong: Zero False Positives</div></li><li><div>How to do it</div></li><ul><li><div>System knows something specific about a user</div></li><ul><li><div>Something you know —&gt; e.g. Passwords</div></li><li><div>Something you have —&gt; e.g. Physical token, phone</div></li><li><div>Something you are —&gt; Fingerprint, retina scanner</div></li></ul><li><div>System asks you to demonstrate this</div></li><li><div>Multi-factor refers to using multiple… factors</div></li></ul><li><div>What counts as “hard”? See: guessing entropy</div></li></ul></ul><div><br/></div><div><span style="font-size: 18px;">Authorization</span></div><ul><li><div>AuthN indicates who the requester is. AuthZ indicates what they can do.</div></li><li><div>DAC is a policy set by the owner. MAC is a policy set by the system</div></li><li><div>DAC</div></li><ul><li><div>Access Control Matrix maps people to resources</div></li><li><div>Can be represented via ACLs or Capability lists</div></li><li><div>Unix: ACLs but with fast access for r/w operations</div><div/></li><ul><li><div>Originally</div></li><ul><li><div>Total of nine bits</div></li><li><div>Owner, group, and others could have r, w, x permissions</div></li><li><div>Check on open(F, mode) call only which returns a file descriptor fd</div></li><li><div>Read and write calls use fd</div></li><li><div>Exists a TOCTOU vulnerability</div></li></ul></ul><li><div>Windows includes concept of “Negative access rights"</div></li><li><div>Hydra uses a “capabilities” system for everything</div></li></ul><li><div>MAC</div></li><ul><li><div>MAC addresses problems with DAC</div><div/></li><ul><li><div>Information Control Problem</div></li><ul><li><div>Alice can never be sure that sensitive data she shares with Bob will not be further shared with others</div></li><ul><li><div>Bob can make a copy of Alice’s file for which he has read access and share this new file containing her data with others</div></li></ul></ul><li><div>Sharing of information user U creates may be constrained by his or her organization</div></li><ul><li><div>Commercial setting </div></li><li><div>Defense and intelligence agencies limit how info can be shared</div></li></ul><li><div>Labels represent sensitivity, etc.</div></li><li><div>Label comparison defined via lattice structure (partial order)</div></li><li><div>BLP Model</div></li><ul><li><div>Rules</div><div/></li><ul><li><div>Simple Security</div></li><ul><li><div>Subject S can read object O if the label of S dominates the label of O</div></li><li><div>Read down rule</div></li></ul><li><div>*-Property</div></li><ul><li><div>Subject S can write object O if the label of S is dominated by the label of O</div></li><li><div>Write up rule</div></li></ul></ul></ul><li><div>Biba is the inverse</div></li></ul><li><div>RBAC defines what roles users can assume AND what permissions are given to roles (instead of users directly getting permissions)</div></li><ul><li><div>Benefits</div><div/></li><ul><li><div>Groups are a collection of users. Different than a role.</div></li><li><div>Size improvements</div></li><ul><li><div>ACM size is U * O</div></li><li><div>Roles size = R * (U + O)</div></li><ul><li><div>As R —&gt; 1, size —&gt; U + O</div></li></ul></ul></ul></ul><li><div>MAC Summary</div><div/></li><ul><li><div>BLP: Provides Confidentiality</div></li><li><div>Biba: Provides Integrity</div></li><li><div>RBAC: C + I</div></li><li><div>Clark-Wilson: I</div></li><li><div>Chinese Wall: C</div></li></ul></ul></ul><div><br/></div><div/><div/><div><span style="font-size: 18px;">SELinux</span></div><ul><li><div>Mandatory access control helps control data, but few OSes support by default.</div></li><ul><li><div>SELinux is a system that adds support —&gt; Redhat, other Linux distress, SEAndroid, KNOX</div></li></ul><li><div>Basis of SELinux is the Linux Security Module</div></li><ul><li><div>Loadable kernel module to separate enforcement from policy</div></li></ul><li><div>SELinux Security Context</div></li><ul><li><div>Accès checked after DAC</div></li><li><div>Policy configurable</div></li><li><div>Context defined as User:Role:Type:Range</div></li></ul><li><div>Enforcement</div></li><ul><li><div>Access: allow source target:class operation</div></li><li><div>Inheritance: Child inherits parent. In the context of files, inherit from parent directory</div></li><li><div>Transition happens through execution</div></li><li><div>Not allowed to override</div></li></ul><li><div>Multi-level security</div></li><ul><li><div>Helps with info flow problems during read and write between parties of different security “levels”</div></li><li><div>SELinux implements BLP and BLP+ (BLP+ refers to BLP but do not allow read up)</div></li><li><div>MLS Policy implemented by policy constraint rules (with extra process expressions e.g. l1 and h1 to refer to low and high contexts). Also new operators like eq, dom, domby, incomparable</div></li></ul></ul><div><br/></div><div><br/></div><div><span style="font-size: 18px;">Covert Channels</span></div><ul><li><div>Informal Definition: Information leakage via paths that can not be protected by MAC (i.e. not legitimate channels)</div></li><ul><li><div>Usually caused by shared resource (CPU, network, etc.)</div></li></ul><li><div>More technical definition: Given MAC policy M, any potential info flow from S_m to S_n is covert if it is forbidden by M</div></li><li><div>Covert channels refer to cooperating processes. If no collusion than called “side channel"</div></li><li><div>What can be done?</div></li><ul><li><div>Detect, Estimate Bandwidth (how bad is it), Mitigation strategies.</div></li></ul><li><div>Detection done via “Shared Resource Matrix”</div></li><li><div>Bandwidth estimation done via computation (depends on channel), but usually computing bits per time interval</div></li><ul><li><div>Noisy channels can exist and they reduce bandwidth</div></li></ul><li><div>Mitigation strategies</div></li><ul><li><div>Don’t resource share</div></li><li><div>Pump abstraction for timing attacks: Insert a “MITM” device which acts as a buffer that normalizes response times to a rolling average</div></li></ul><li><div>Real attacks</div></li><ul><li><div>Meltdown and Spectre (technically side channel)</div></li><li><div>RamBleed</div></li></ul></ul><div><br/></div><div><br/></div><div><span style="font-size: 18px;">Distributed Systems Security</span></div><div><font style="font-size: 12px;"><span style="font-size: 12px; font-weight: bold;">Basics</span></font></div><ul><li><div>“Principals” make requests to request operations that exist on remote hosts</div></li><li><div>Challenges</div></li><ul><li><div>Authentication is hard because there is no trusted path between user and trusted TCB node</div></li><li><div>Authorization between nodes implies node must speak on other’s behalf</div></li><li><div>Access control hard when resources are distributed</div></li></ul><li><div>Handling distributed requests</div></li><ul><li><div>Requesting principal must be at least as trusted as a principal authorized to access the resource</div></li><li><div>Communication channels must be principals themselves</div></li></ul><li><div>Compound principals can logically exist (e.g. “Alice as Manager”, “Alice and Bob”, “Alice for Bob"</div></li><li><div>Principals make statements</div></li><li><div>Statements simply refer to types of formal logic</div></li></ul><div><br/></div><div><span style="font-weight: bold;">Getting security</span></div><ul><li><div>Secure Communication Channels</div></li><ul><li><div>Attacks can be passive or active</div></li><li><div>Need confidentiality, integrity, and authenticity over channel</div></li></ul><li><div>Key Sharing</div></li><ul><li><div>Generate K and share with A and B</div></li><li><div>A encrypts messages sent to B with K</div></li><li><div>Encrypted message includes B’s identifier for K (in plaintext)</div></li><ul><li><div>B knows what key to use to decrypt</div></li><li><div>Share key with a key exchange protocol</div></li></ul><li><div>Share initial key via Diffie-Hellman</div></li></ul><li><div>Need trusted entity to assign keys to entity names: CA</div></li><ul><li><div>CA is trusted</div></li><li><div>CA speaks for all principals</div></li></ul><li><div>Cert revocation</div></li><ul><li><div>CAs should be mostly offline</div></li><li><div>Certificates should be revoked —&gt; Have an online service which tracks revoked certs and refreshes a “revocation list"</div></li><li><div>Trusting a single CA is problematic. May choose to use a hierarchy of CAs + trust chains</div></li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Secure Boot and Loading</span></div><ul><li><div>Secure Loading</div></li><ul><li><div>A program can be characterized by its digest (Hash)</div></li><li><div>Program P comes from trusted file system; or</div></li><li><div>P comes form an untrusted file system, but node (some principal as an OS) has a digest D for P</div></li><ul><li><div>A loads P iff P’s computed digest matches D. Call this “attestation"</div></li></ul></ul><li><div>Secure Boot</div></li><ul><li><div>If P (as above) is the OS, call this “Secure Boot"</div></li><li><div>Physical hardware is base case. Assume as part of installation M comes with keys and certificate.</div></li><li><div>Must keep keys separate from OS. Revisit SGX, etc.</div></li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Delegation</span></div><ul><li><div>Want to differentiate a user delegating authority to “Machine as OS”, not let machine as OS become user.</div></li><ul><li><div>Delegation: “B for A”, not “B as A” or “B speaks for A"</div></li><ul><li><div>Requires both sides to accept delegation</div></li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">Together</span></div><ul><li><div>Encryption and secure channel protocol handle cross-node issues</div></li><li><div>Machine M, with certificate, is root of trust</div></li><ul><li><div><span style="color: rgb(0, 0, 0);">Is this reasonable?</span></div></li></ul><li><div><span style="color: rgb(0, 0, 0);">Secure boot transfers trust to OS</span></div></li><ul><li><div><span style="color: rgb(0, 0, 0);">Challenges in practice?</span></div></li></ul><li><div><span style="color: rgb(0, 0, 0);">Delegation during login allows a node to demonstrate to remote server that the user actually logged in</span></div></li><ul><li><div><span style="color: rgb(0, 0, 0);">Do users have certificates?</span></div></li></ul><li><div><span style="color: rgb(0, 0, 0);">SGX an example of this in real life</span></div></li></ul><div><br/></div><div><br/></div><div><span style="font-size: 18px;">Database Security</span></div><ul><li><div>Securing a DB requires: Authentication; Authorization; Audit, but some things are harder: Inference attacks</div></li><li><div>Want RBAC-like model for structured DBs.</div></li><li><div>Stored procedure security</div></li><ul><li><div>Two “roles”: Definer and invoker. Definer can execute without needing separate privilege for underlying objects. Invoker must have access to objects required by procedure</div></li></ul><li><div>DB “View” refers to a subset of the actual DB such that the resulting data matches a specific user’s security level</div></li><li><div>Inference Attacks</div></li><ul><li><div>Functional Dependency attacks: Get (Name, Rank), Get (Rank, Salary). Combine to disclosure salary for name.</div></li><li><div>Statistical queries: Use statistics averages to guess sensitive data with high precision</div></li><li><div>Defenses:</div></li><ul><li><div>Don’t allow queries that return sufficiently small or large results. However, can be broken using Tracker attack</div></li><ul><li><div>C1 = Female students</div></li><li><div>C2 = Out of state students</div></li><li><div>T(Tracker) = C1 AND ~C2</div></li><ul><li><div>q(C) = q(C1) - q(T)</div></li></ul></ul></ul></ul><li><div>Better solution: De-identification and Differential Privacy</div></li><ul><li><div>K-Anonymity</div></li><ul><li><div>DB transformed so at least k different rows with same “trace” are produced</div></li><li><div> Utility of DB drops with increasing K</div></li><li><div>Linking attack s and l-diversity are still a problem</div></li></ul><li><div>Differential Privacy</div></li><ul><li><div>Curator will add noise to response R to return R'</div></li><li><div>This needs to be done carefully so noise cannot be easily cancelled out with multiple queries</div></li><li><div>Guassian or Laplace mechanism - noise derived from these distributions</div></li><li><div>Local differential privacy (LDP)</div></li><ul><li><div>Users locally perturb their data and share it</div></li><li><div>No need for trusted curator</div></li></ul></ul></ul><li><div>What about Multi-Level Databases. e.g. Can we add BLP to databases?</div></li><ul><li><div>SeaView once such instance of a MLD with BLP support</div></li><li><div>Access class is assigned at an element in row</div></li><li><div>Tuple access class is LUB of access classes of elements in tuple (row)</div></li><li><div>Relation/table access class is GLB of any element in a type in table</div></li><li><div>Database access class is GLB of any table access class.</div></li><li><div>In order for data to be accessible, tuple key access class is the least privileged class in a tuple</div></li><li><div>User’s see elements in a “read down” fashion. If sensitive data is too high, cause it to become NULL</div></li><li><div>Poly-instantiation</div></li><ul><li><div>Visible: A lower access class value is visible to higher access class user but is not overwritten</div></li><li><div>Invisible: A lower access class level user does not see a more sensitive value</div></li></ul></ul></ul><div><br/></div><div><br/></div></body></html>
